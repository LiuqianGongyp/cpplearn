# 计算机网络

1. ## TCP/IP模型和OSI模型

   | TCP/IP模型 |  OSI模型   |
   | :--------: | :--------: |
   |   应用层   |   应用层   |
   |   应用层   |   表示层   |
   |   应用层   |   会话层   |
   |   传输层   |   传输层   |
   |   网络层   |   网络层   |
   |   链路层   | 数据链路层 |
   |   链路层   |   物理层   |

   

2. ## 从输入URL到页面展示发生了什么

   1. 在地址栏中输入URL
   2. 浏览器先查看是否有缓存、缓存是否新鲜
      - 若资源未缓存，发起请求
      - 若缓存存在则检查缓存是否新鲜，足够新鲜将缓存提供给客户端，否则与服务器验证
      - HTTP1.0和1.1有两种确认缓存是否新鲜的`HTTP`头，分别是Expires` 和 `Cache-Control
   3. 浏览器解析URL获取协议、主机、端口、路径
   4. 组装HTTP请求报文
   5. 先检查浏览器DNS缓存，若没有再检查操作系统的DNS缓存，还没有再检查本地硬盘的host文件，还没有向本地DNS服务器发送请求，本地DNS服务器检查缓存，若有则直接返回对应的IP地址，否则本地DNS服务器向DNS根服务器进行查询，开始DNS递归查询（根DNS服务器返回顶级域名服务器的 IP 地址给本地DNS 服务器，本地DNS 服务器向顶级域名服务器发起查询，顶级域名服务器返回二级域名服务器IP，直到找到对应的 IP 地址），本地DNS服务器将IP地址返回给浏览器。
   6. 打开⼀个`socket`与⽬标`IP`地址端⼝，建立TCP连接
      1. 发起方发送SYN=1，seq=x
      2. 另一方发送SYN=1，ACK=1，seq=y，ack=x+1
      3. 发起方发送ACK=1，ack=y+1，seq=x+1
   7. 向服务器发起http请求
   8. 服务器接受请求并解析，将请求转发到服务程序
   9. 服务器检查是否有缓存验证信息，若验证缓存新鲜则返回304等状态码信息
   10. 处理程序读取完整请求准备HTTP响应。
   11. 服务器将响应体通过TCP连接发给浏览器。
   12. 浏览器接收http响应，根据情况选择断开TCP连接或保留重用
       1. 根据什么判断
          1. HTTP版本
             1. **HTTP/1.0**：默认情况下每次请求后关闭连接，除非响应头中包含 `Connection: keep-alive` 指示保持连接。
             2. **HTTP/1.1**：默认情况下保持连接，除非响应头中包含 `Connection: close` 指示关闭连接。
             3. **HTTP/2**：始终使用单个连接，并在该连接上进行多路复用，不会轻易关闭连接。
          2.  Connection头部字段
             1. **Connection: keep-alive**：指示服务器和客户端希望保持连接并重用它进行后续请求。浏览器会尽可能保留连接，直到达到超时时间或连接限制。
             2. **Connection: close**：指示服务器或客户端希望关闭连接。浏览器在处理完当前请求后会关闭连接。
          3. 资源加载需求
             1. **多资源请求**：在加载一个网页时，通常需要请求多个资源（如HTML、CSS、JavaScript、图片等）。为了提高性能，浏览器会尽可能保持连接，以减少重复的TCP握手和延迟。
             2. **单资源请求**：如果只需要加载单个资源，并且没有后续请求，浏览器可能会选择关闭连接。
          4. 连接池限制
             1. **最大连接数**：浏览器通常会限制与同一主机的最大连接数。如果已经达到连接数限制，可能会关闭一些空闲连接来为新请求腾出空间。
             2. **连接空闲时间**：如果连接在一段时间内保持空闲且没有新请求，浏览器可能会关闭该连接以释放资源。
          5. 服务器配置
             1. **服务器支持**：服务器配置可能影响连接的保持时间和策略。例如，服务器可以通过 `Keep-Alive` 头部字段指定最大请求数和超时时间。
             2. **服务器限制**：如果服务器配置了较短的空闲超时时间或严格的连接数限制，浏览器可能会更频繁地关闭连接。
       2. 关闭TCP的步骤
          1. 主动关闭方发送FIN=1，seq=x
          2. 另一方发送ACK=1，seq=u，ack=x+1
          3. 另一方发送FIN=1，seq=v，ack=x+1
          4. 主动方发送ACK=1，ack=v+1，seq=x+1
   13. 检查响应状态码，根据不同情况进行处理
   14. 如果有资源可以缓存则缓存
   15. 载入解析的资源，渲染界面

3. ## HTTP请求报文和响应报文是怎样的

   1. 请求报文

      请求行：请求方法、请求URL、http的版本

      请求头部：包含若干个属性，格式为“属性名:属性值”，常用的有：

      - host：请求的服务器的域名
      - accept：客户端能够处理的媒体类型
      - accept-Encoding：客户端能够解码的类型
      - Authorization：用于认证的凭证
      - Content-Length：请求体的长度
      - Content-type：请求体的类型
      - Cookie：存储在客户端的cookie数据
      - If-None-Match：资源的Etag值，用于缓存控制
      - Connection：连接管理选项

      空行：分隔请求头部和请求体

      请求体：请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据

   2. 响应报文

      状态行：Http版本、状态码、状态消息

      响应头：格式为“属性名:属性值”，常见的有

      - Server：服务器应用程序软件的版本和名称
      - Content-Type：响应体的媒体类型。
      - Content-Length：响应体的长度（字节数）
      - Set-Cookie：在响应中设置Cookie
      - **Last-Modified**： 资源最后被修改的日期和时间
      - **ETag**: 响应体的实体标签，用于缓存和条件请求

      空行

      响应体：服务端实际传输的数据，可能为空

4. ## HTTP请求方式有哪些

   1. Get 没有请求体，是请求数据的，大小有显示2-8kb，通常不超过4
   2. Post 是上传数据的，大小没有限制
   3. Put
   4. Delete
   5. Options
   6. Head
   7. Connect
   8. Patch 已知资源进行局部更新
   9. Trace 追踪路径

5. ## GET请求和POST请求的区别

   1. 安全性：Get请求参数是写在URL中的，隐私性差，POST的数据是写在请求体中的，不会显示在URL中，相对更安全。
   2. 大小限制：Get请求是写在URL中的，浏览器对URL有长度限制，但POST写在请求体中，大小没有限制。
   3. 幂等性：Get请求每次的结果是相同的，POST会对服务器数据进行修改，不能保证幂等。

6. ## HTTP请求中常见的状态码

   1. 1xx（信息性状态码）
   2. 2xx（成功）
      - 200 成功
      - 204 成功，但没有返回结果
      - 206 客户端一部分资源，服务端成功响应，返回一范围资源
   3. 3xx（重定向）
      - 301 永久重定向
      - 302 307 临时重定向
      - 303 由于请求的资源存在另一个URL，应该使用Get方法定向获取请求的资源
      - 304 客户端采用带条件的访问某资源，服务器找到了资源，但请求的条件不满足
   4. 4xx（客户端错误）
      - 400 报文存在语法错误 
      - 402 需要认证/认证错误
      - 403 请求被服务器拒绝
      - 404 服务器找不到资源
   5. 5xx（服务器错误）
      - 500 服务器执行请求时发生了错误
      - 503 服务器维护或者过载

7. ## 什么是强缓存和协商缓存

   1. 强缓存

      如果缓存资源有效直接使用缓存资源，通过http头属性中的expires属性和cach-control属性控制

      - expires：一个绝对时间，表示资源的过期时间，在这个时间前的为在有效期，不必再向服务器发起请求。

      - cach-control：可设置以下字段

        max-age：缓存的最大有效期，秒为单位

        no-store：禁止缓存

        no-cache：要询问服务器缓存是否发生变化

        private：只允许用户浏览器缓存

        public：可以被任何对象缓存

        s-maxage：有限级高于max-age或者Expires，仅适用于共享缓存

        max-stale：可以使用过期缓存，但不能超过给定的时间限制

      cach-control优先级高于Expires

   2. 协商缓存

      要满足条件max-age过期了或者no-cache

      采用协商缓存要向服务器发起缓存验证，若缓存没有更改，服务器会返回304

      还可以使用Etag或者Last-Modified属性来设置。

      浏览器请求过一次资源以后，下次请求资源时，使用IF-Modified-Since属性，若服务器比较未在IF-Modified-Since之后修改，则返回304，让浏览器使用本地缓存。但只能精确到秒级

      Etag更精确，每次修改资源时，其值会更改，下次请求资源时，使用IF-None-Match属性，若服务器比较F-None-Match属性于Etag相同，则返回304，不适用于负载均衡。

   一般来说，强缓存和协商缓存要一起使用，先看是否命中强缓存，命中则直接使用资源，否则，将根据头信息向服务器发起请求，使用协商缓存，协商缓存命中，则浏览器使用本地资源，否则服务器返回最新资源给浏览器。

8. ## HTTP1.0和HTTP1.1的区别

   1. host域

      http1.0不支持host域，只能使用ip地址，但随着虚拟主机技术的发展，一台物理服务器上可以有多个虚拟主机，他们域名不同，共享一个ip地址

   2. 安全性

      http1.1引入了TLS/SSL，保证了数据传输的安全性

   3. 状态码

      http1.1新增了20多个状态码，如409（表示请求的资源与资源的当前状态发生冲突），206等

   4. 长连接

      http1.0默认使用短链接，在http1.1中connection字段默认设置为keep-alive，长连接有两种方式，一种为非流水线一种是流水线，流水线是，接收到响应前可以再次发起请求，非流水线要接收到响应后才能再次发起请求

   5. 缓存处理

      引入了Etag和Cach-control属性

   6. 带宽优化

      http1.0中只需要某个对象的部分，但要整个发送，存在着带宽浪费并且不支持断点续传等技术，，在http1.1中引入了range关键字，可以请求部分资源。

9. ## HTTP2.0与HTTP1.1的区别?

   1. Http2.0采用二进制格式、1.1采用文本格式

   2. http2.0可以实现多路复用，在http1.1中虽然用流水线方式实现了并发，但效果并不好，一个请求的想要要在一个之后，在http2.0中的多路复用有request_id来标志顺序，可以在一个连接上实现并发。

   3. 头部压缩，当需要加载的资源多时，头部字节数也很高

   4. 数据流优先级

      允许客户端设置哪些资源先传输，优化页面加载速度

   5. 服务器推送

      服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。

10. ## HTTP3.0有了解过吗?

    1. 基于UDP而不是TCP
    2. 更安全，TCP和TLS是分开发生的，对于TCP来说可以发送加密的数据也可以发送明文数据，而http3.0在QUIC上运行，默认提供加密，对传输进行加密。
    3. 允许 TLS版本协商与加密和传输握手同时发生
    4. 0-RTT，对于已连接的服务器可以跳过握手。

11. ## HTTPS和HTTP有哪些区别

    1. Https在http上增加了SSL层，保证数据安全，http是明文传输
    2. https需要证书CA，而免费的证书很少，一般需要花钱
    3. https一般使用端口443，http一般使用端口80
    4. http是无状态的连接，https是支持数据加密、身份认证的连接

12. ## HTTPS工作原理

    1. 首先建立TCP连接（这里有三次握手）

    2. 然后TLS握手

       - Client Hello 包含客户端支持的版本、加密算法、压缩算法、和客户端选定的随机数。（明文传输）
       - Server Hello 选定版本、加密算法、会话 ID以及服务器选定的随机数，除此之外，发送Certificate包含服务器证书（包含证书支持的域名、发行方和有效期等信息）、然后发送Server Key Exchange传输公钥以及签名等信息，可以向客户端发送CertificateRequest，验证客户端的证书，最终以Server done Hello表示发送完毕。（明文传输）
       - 客户端验证证书（如何验证？）。验证通过后，发送Client Key Exchange 消息，包含**使用服务端公钥加密后的随机字符串**，之后发送Change Cipher Spec，表示之后都是密文发送，然后发送Finished，其中包含加密后的握手信息。
       - 服务器接收到Change Cipher Spec 和 Finished 消息后，发送Change Cipher Spec消息，通知客户端后面的数据段会加密传输，发送Finished消息，验证客户端的 Finished 消息并完成 TLS 握手；

       注：客户端随机数（Client Random）和服务器随机数（Server Random）与预主密钥（Pre-Master Secret）一起通过伪随机函数（PRF）生成会话密钥。

       ***如何验证证书的合法性***

       浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书。

       浏览器需要对证书做以下验证：

       - 验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证。
       - 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证。

       - 判断证书是否被篡改。需要与 CA 服务器进行校验。
       - 判断证书是否已吊销。通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现。

       其中 OCSP 可用于第 3 步中以减少与 CA 服务器的交互，提高验证效率。

       以上任意一步都满足的情况下浏览器才认为证书是合法的。

    3. 在已经建立好的TCP 和 TLS 通道上使用http协议传输数据

13. ## TCP和UDP的区别

    1. TCP面向连接、UDP无连接
    2. TCP面向报文、UDP面向字节流
    3. TCP是一对一、UDP可以一对一、一对多、多对多
    4. UDP更快、延迟低
    5. TCP是可靠的，UDP不是
    6. TCP有拥塞控制机制，UDP没有
    7. TCP将大数据分为多个小段，每段都有序号，动态调整数据段大小，UDP受底层网络最大传输单元MTU限制，不能超过MTU，一旦分片后一片丢失，整个数据包被丢弃。
    8. 适合的应用场景不同
    9. 头部大小不能，TCP最小20字节、UDP固定8字节
    10. TCP协议下双方都有发送缓冲区和接收缓冲区，UDP没有实际意义上的发送缓冲区，只有接收缓冲区。两者都是全双工，但是UDP需要将自身发送数据先转给Linux内核，然后再由内核发送出去。

14. ## TCP连接如何确保可靠性

    1. 建立连接：通过三次握手建立连接，保证连接实体真实存在
    2. 序号机制：保证数据按序到达
    3. 超时重传：发送方一直接收不到应答，会重传
    4. 数据校验：保证接收到数据的准确
    5. 流量控制：当接收方来不及处理发送方的消息的时候，会用滑动窗口告诉发送方降低发送速率，避免丢包
    6. 拥塞控制：有慢开始、拥塞避免、快重传、快恢复的机制

15. ## UDP怎么实现可靠传输

    传输层无法保证数据的可靠性的传输，只能通过应用层来进行实现。实现的方式可以参照tcp可靠性传输的方式（确认机制，重传机制，窗口确认机制），只是实现不在传输层，实现转移到了应用层。

    目前有**RUDP、RTP、UDT**利用UDP实现了可靠的数据传输

    RUDP：有改进的拥塞控制机制，实现TCP方式的流控制行为

    RTP：引入了序号机制，实时发送，接收方可以根据序号重组

    UDT：新的拥塞控制机制和数据校验机制

16. ## 三次握手的过程，为什么是三次

    如果是两次，那么不能实现服务端和客户端都进行确认。也就是说，三次握手为了防止失效的请求报文传送到服务端产生连接误判。

17. ## 四次挥手的过程，为什么是四次

    服务端可能有未发送完的数据仍需要发送，不能在确认接收到FIN时，关闭连接。因此，FIN需要和ACK分开发送。

    **为什么需要TIME_WAIT状态**

    保证对FIN发送的ACK到达服务器，实现可靠的关闭连接

18. ## HTTP的Keep-Alive是什么?TCP 的Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗?

    不是。

    - Http的Keep-Alive是应用层是协议，为了提高请求和响应的效率，是为了让多个请求-响应对在一个连接上进行，避免多次建立连接，带来额外的开销，同时减少请求的延迟，节省资源。
    - TCP的KeepAlive是传输层的协议，为了保证连接的可靠性，是在不可靠的网络环境中，检测空闲的Tcp连接是否还活着，如果连接不可用则进行清理。

19. ## DNS查询过程

    具体在2中，这里强调递归查询和迭代查询

    **递归查询**是指主机向本地DNS服务器发起请求，本地DNS服务器不知道，但不会让主机继续查询，而是以DNS客户的身份向根域名DNS服务器发起查询

    **迭代查询**是指根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。

20. ## CDN是什么

    Content Delivery Network，内容分发网络，分布式的网络基础设施。目的是为了加速，让用户就近访问数据，以更快速度获得数据。

    **缓存更新**有两种方式：1.服务器主动更新，CDN节点被动接受。2.用户查询时，CDN节点中没有，向上游服务器请求获得资源，资源返回发送给用户，并将资源缓存在CDN节点中。

    **当用户请求一个文件时，cdn的工作过程如下：**

    - dns请求本地DNS服务器
    - 本地DNS服务器迭代查询服务器的GSLB
    - 服务器根据本地DNS分配最佳节点，返回ip
    - 用户访问最佳节点，发起查询
    - 如果该节点没有用户想要获得的数据，则通过内部路由访问上一节点，直到找到文件或到达源站位置
    - 节点缓存数据，下次请求该文件时可以直接返回

21. ## Cookie和Session是什么?有什么区别?

    - Cookie是一段文本信息，是服务器发给客户端浏览器用来保存客户端状态的。如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端下一次发起请求时，会在请求中带上cookie的信息，服务器可以修改Cookie的内容
    - Session是另一种记录客户状态的机制，存储在服务器上，服务器会为每一个用户建立一个session，他们有不同的sessionid。当有很多Session时，会增加服务器的负载

    **区别**

    - 安全性：Cookie可以被修改，实现欺骗。Session的安全性更强
    - 存储位置：Cookie存储在客户端浏览器，Session存储在服务器上
    - 保存信息不同：重要信息一般放在Session中
    - 数据大小：Cookie单个不超过4kb，一般浏览器要求最多保存20个站点的cookie，Session受服务器存储限制影响
    - 服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。

# 操作系统

1. ## 进程和线程的区别

   - 进程：是系统资源分配的基本单位
   - 线程：是系统调度和分派的基本单位，是进程中执行运算的最小单位。

   区别：

   1. 进程之间地址空间是独立的，同一个进程的线程共享一个地址空间
   2. 进程之间拥有的资源是独立的，同一个进程的线程资源共享
   3. 线程切换的资源消耗更少
   4. 一个进程崩溃不会引起其他进程的崩溃，但一个线程崩溃会引起它所在进程崩溃，从而同一个进程的线程都会崩溃
   5. 线程必须要依赖一个进程，不能独立执行。一个独立的进程有一个程序入口和出口

2. ## 并行和并发有什么区别

   - 并行：同时执行多个任务
   - 并发：在同一时间段执行多项任务，并不一定同时执行

   | 特性     | 并行             | 并发                             |
   | -------- | ---------------- | -------------------------------- |
   | 定义     | 同时执行多个任务 | 在同一时间段执行多项任务         |
   | 目的     | 提高性能         | 提高效应速率，提高系统利用率     |
   | 硬件需求 | 多核或多处理器   | 单处理器即可                     |
   | 任务执行 | 真正同时进行     | 通过任务切换使任务逻辑上同时进行 |

   

3. ## 解释一下用户态和核心态

   用户态和核心态是操作系统的两种运行状态。

   - 用户态：运行在3级特权级，是最低的。能访问的内存空间和资源受限，处理机可被抢占
   - 核心态：运行在0级特权级，是最高的。能访问所有的内存空间和资源，处理机不可被抢占

   为什么有这两种区别：区别执行 **特权指令 与非特权指令**，对一些危险的指令（如清内存、设置时钟等）作出限制，保证计算机的安全

   如何切换：

   - 系统调度
   - 中断
   - 异常

4. ## 进程调度算法你了解多少

   进程调度算法是操作系统中负责管理和分配CPU时间给不同进程的机制。一般分为抢占式和非抢占式两大类。算法设计一般考虑到CPU利用率、响应时间、周转时间、等待时间、系统吞吐量几个标准。

   经典算法：

   1. 先来先服务FCFS
   2. 短作业优先SJF
   3. 最短剩余时间优先SRTF（可抢占）
   4. 高响应比优先
   5. 优先级调度算法
   6. 多级反馈调度算法（优先级高的队列时间片短，先放入高优先级队列，不能在一个时间片内执行结束，放入第一级的队列尾，一直至放到最低优先级队列中，变成时间片轮转算法）（可抢占）
   7. 时间片轮转RR

5. ## 进程间有哪些通信方式

   1. 管道

      其大小受限且只能承载**无格式字节流**的方式

      - 无名管道：要有亲缘关系的进程之间才能使用
      - 有名管道：通过文件系统的路径名进行识别，不需要有亲缘关系，存在于文件系统中

   2. 消息队列

      存在在系统内存中，可以实现异步通信

      - 直接通信

        将消息直接悬挂在接收消息一方的消息缓冲队列上

      - 间接通信

        将消息放在一个中间的实体，被称为信箱

   3. 共享内存

      通过内存地址映射，共享一块内存，效率高，但有同步问题，需要信号量配合。持久化

   4. 信号量：一个计数器

   5. 信号：一种通知机制

   6. 套接字

   7. mmap：映射到文件，从而达到进程间通信的目的

6. ## 解释一下进程同步和互斥，以及如何实现进程同步和互斥

   - 同步：协调进程的执行顺序，使其按照预定顺序访问共享资源或数据。保证进程在关键点上的执行顺序符合逻辑要求，避免发生不一致或错误。
   - 互质：确保在任何时刻，只有一个进程能够访问共享资源或执行代码段，从而避免数据竞争或不一致问题。

   **如何实现**

   - 信号量 （PV操作，若大于零，P-1进去执行，否则等待，V+1，若有等待，则唤醒一个）

   - 信号
   - 管道
   - 消息队列
   - 共享内存
   - 互斥锁
   - 条件变量 要和互斥锁结合使用，确保修改条件时的互斥性
   - 读写锁 云锁多个读者同时访问，但写必须独占锁
   - 屏障

7. ## 什么是死锁，如何预防死锁?

   **死锁**：两个或多个进程都在等待其他进程释放资源，而无法继续执行的情况。

   **必要条件**：

   - 互斥条件
   - 占有且等待
   - 不可抢占
   - 循环等待

   **死锁预防**：打破至少一个必要条件

   **死锁避免**：实施分配资源信息和合理的分配策略，例如银行家算法，若分配后进去不安全状态，找不到一个安全地序列，则不分配。

8. ## 介绍一下几种典型的锁

   1. 互斥锁
   2. 自旋锁  不阻塞，不停的轮询锁的状态
   3. 读写锁
   4. 悲观锁，上述三种都是悲观锁，悲观锁在访问共享资源时会加锁，他认为冲突发生的概率非常高
   5. 乐观锁，在访问共享资源时会不加锁，但完成操作时会检查这段时间是否有冲突发生，有则重试。一般用在冲突概率非常低、加锁成本很高的场景中
   6. 递归锁，可以在线程中多次加锁，只有加锁和解锁次数匹配时，才视为真正释放锁。

9. ## 讲一讲你理解的虚拟内存

   一种内存管理技术，实现一块虚拟的、在逻辑上连续的大的内存，用大容量的外存来扩充内存。

   **优点**

   简化编程、扩充内存、提高内存利用率、进程隔离

   **工作原理**

   依赖于地址转换、页面调度、页面置换算法

10. ## 你知道的线程同步的方式有哪些?

    1. 线程同步和进程同步的本质区别在于锁放在哪

    2. 常用的方式

       - 信号量 （PV操作，若大于零，P-1进去执行，否则等待，V+1，若有等待，则唤醒一个）

       - 互斥锁
       - 条件变量 要和互斥锁结合使用，确保修改条件时的互斥性
       - 自旋锁
       - 读写锁 云锁多个读者同时访问，但写必须独占锁
       - 屏障

11. ## 有哪些页面置换算法

    1. 最优页面置换算法
    2. FIFO
    3. LFU
    4. LRU
    5. 第二次机会页面置换算法（对FIFO的改进，若最后一个页面的R位是0，则删掉，不然改为0重新放进去）
    6. 时钟页面置换算法（对第二次机会页面置换算法，做成环形的，向前移动指针就可以，不用取出再放入）

12. ## 熟悉哪些Linux命令

    - 文件管理

      - mkdir

      - ls

      - mv

      - cp

      - rm

      - cd
      - touch
      - cat

    - 进程管理
      - ps
      - top
      - kill
      - nice
    - 权限管理
      - chmod
      - chown
    - 网络通讯
      - ping
      - netstat
      - ip
      - wget

13. ## 如何查看某个端口有没有被占用

    netstat -tuln | grep :80

14. ## 说下 select、poll、epoll

    都是Linux系统中对IO复用的实现

    - select：本质上是通过设置或检查fd_set来进行下一步处理
      - 需要维护一个巨大的存放fd的数据结构
      - 每次调用select都需要将进程加入到所有监视 fd 的等待队列中，每次唤醒都需要从每个队列中移除，而且每次都要将整个fd_set列表传递给内核
      - 当函数返回时，系统会将就绪描述符写入fd_set中，并将其拷贝到用户空间。进程被唤醒后，用户线程并不知道哪些fd收到数据，还需要遍历一次。
    - poll：将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd
      - 和select一样，都需要来回拷贝全部的文件监听描述符
      - 采用链表方式代替原来的fd_set结构
      - 水平触发
    - epoll：使用mmap减少复制开销，用一个文件描述符管理多个描述符，将用户进程监控的文件描述符的事件存放到内核的一个事件表
      - 使用事件通知机制，当事件发生时回调而不是遍历
      - 红黑树将存储 epoll 所监听的 FD。
      - 边沿触发

15. ## Linux进程管理机制

    1. 创建 fork vfork
    2. 终止 exit _exit wait waitpid
    3. 调度
    4. 进程状态
    5. 进程间通信
    6. 进程管理命令 ps（查看进程信息）、top（动态查看进程状态）、kill（终止进程）、nice（改变进程优先级）
    7. 进程控制块（PCB）
       - Linux中每个进程都由一个`task_struct`结构体表示，包含进程状态、调度信息、内存映射、文件描述符表、信号处理等。

# 数据库

1. ## Redis的过期删除策略和内存淘汰策略

   1. 过期删除策略
      - 定期删除：每100ms在字典中随机选20个查看是否过期，过期就删除，若过期超过1/4就在随机选20个。
      - 惰性删除：对查询的key进行检查，若过期了，会立即被删除。
   2. 内存淘汰策略
      - no-eviction 对于写请求不再提供服务
      - allkeys-lru
      - volatile-lru
      - allkeys-lfu
      - volatile-lfu
      - allkeys-random
      - volatile-random
      - volatile-ttl 选取即将过期的key，进行淘汰

2. ## 一条SQL查询语句是如何执行的?

   mysql的架构如下图

   ![MySQL 基本架构示意图](D:\xdu\面试\fig\1356806-20190928025825417-1905239052.png)

   1. 在执行查询要与数据库建立连接，处理连接有专门的连接器，建立连接之后要进行权限验证，首先输入用户名密码验证身份，验证失败，断开连接，验证成功后，连接器会从权限表中读取用户的权限，之后这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。

   2. 查询缓存命中直接返回结果（Mysql8.0取消了自己的缓存）

   3. 如果缓存未命中，开始执行语句

      - 解析（词法解析、语法分析、语义分析）*分析器*

      - 优化，生成执行计划（在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序）*优化器*

      - 执行  *执行器* 

        打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

   4. 返回结果

3. ## 数据库的事务隔离级别有哪些?

   - **什么是事务**

     事务是应用程序中一系列严密的操作，每个操作都要全部成功执行，否则在每个操作中所作的所有更改都会被撤消。

   - 隔离级别

     - 可读未提交数据（会造成脏读：读取到未提交数据）
     - 读已提交（可能会有不可重复读和幻读）
     - 可重复读 Mysql默认 可能会幻读 InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题
     - 可串行化 强制事务排序，使之不可能相互冲突

4. ## 事务的四大特性有哪些?

   ACID 原子性、一致性、隔离性、持久性

5. ## MySQL的执行引擎有哪些?

   - InnoDB

     支持事务安全

     支持行级锁，支持外键

     支持读写并发，写不阻塞读

   - MyISAM

     表级锁，不支持事务和行级锁定

     提供了较高的插入、查询性能

     适合读密集型

   - MeMORY

     适合存储临时表，放在内存中，重启之后会丢失

   - CSV

     适合在不同数据库之间导入导出

     不允许空行、不支持索引

     格式通用、可以直接编辑

   - Archive

     适合归档和存储历史数据

     空间经过压缩

     不支持索引和事务

6. ## MySQL为什么使用B+树来作索引

   对于这个问题，不单单要考虑数据结构还要考虑磁盘I/O操作次数。磁盘I/O操作的速度很慢，B+树的节点个数不限制为两个，可以有效降低磁盘I/O操作次数。

   MySQL查询的过程是先从磁盘中读取索引，再根据索引查找。

   二分查找的效率明显较好。

   但二叉查找树深度高，会带来大量的I/O操作。

   MySQL查询常用范围查询，B树和B+树在面对范围查询时，由于B+树叶子节点之间链接为链表，因此只需要查找到一个范围节点之后向后，顺序找到范围内的所有记录。

   B+树中含有的冗余信息使其能够在插入和删除时有更少的树结构的变化，有效降低I/O操作次数。

   其优势可以总结为：

   - 顺序访问性能优势、支持范围查询
   - 在插入和删除时能够保证树的高度平衡
   - 适合磁盘存储

7. ## 说一下索引失效的场景?

   1. 全表扫描 如count(*)
   2. 使用逻辑非等操作，NOT，IS  NOT NULL， ！=， <>
   3. 索引未维护
   4. LIKE中通配符在开头
   5. 查询条件覆盖索引列的大多数值
   6. 临时表或派生表
   7. 对索引进行计算或使用函数或存在隐式转换
   8. 联合索引未按照最左前缀原则
   9. 索引列使用OR连接多个条件
   10. 索引列在IN子句中包含大量值

8. ## undo log、redo log、binlog 有什么用?

   1. undo log（回滚日志）

      主要用于事务回滚或者MVCC。记录了数据修改前的状态，保证事务的原子性，当回滚事务时，恢复数据库原来的状态

   2. redo log（重做日志）

      存储数据修改的操作，即使事务提交后立即崩溃，也能将数据库恢复到事务提交后的状态，保证数据库的持久性

   3. binlog（二进制日志）

      存储所有让数据库发生改变的SQL语句，当重放时可以恢复到每个时间节点的状态。用来应对灾难后恢复或者进行主从数据库同步。

9. ## 什么是慢查询?原因是什么?可以怎么优化?

   - 慢查询

     查询语句执行时间过长，超过预定的阈值。

   - 原因

     - 未使用索引优化
     - 锁竞争
     - 硬件设备受限
     - 复杂的连接和子查询
     - 数据量过大

   - 优化

     - 优化查询语句 多层嵌套改为多次查询 避免全表扫描
     - 优化数据库结构
     - 减少长事务的使用
     - 避免全表锁和长时间持有锁

10. ## MySQL和Redis的区别?

    1. MySQL是关系型数据库，Redis是非关系型数据库
    2. MySQL存储在磁盘上，Redis存储在内存上
    3. 数据类型不同，MySQL一般是数值、时间/日期、字符串，Redis有hash、List、set、Zset等
    4. Redis的读取更快，但更为昂贵
    5. 一般结合使用，对于需要高性能的地方使用Redis，不需要高性能的使用MySQL
    6. MySQL用于持久化存储数据，Redis可持久化也可做缓存

11. ## Redis有什么优缺点?为什么用Redis查询会比较快

    - **优点**
      1. 内存数据库，查找和操作的时间复杂度都是O (1) ，纯内存操作，性能出色，是已知最快 Key-Value 数据库，定期通过异步操作把数据库数据 flush 到硬盘上进行保存，实现持久化
      2. 丰富的特性：支持多个DB，支持事务，key过期策略
      3. 丰富的数据结构，单个 Value 的最大限制是1GB
    - **缺点**
      1. 单线程难以发挥多核的优势
      2. 完全重同步生成.rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽
      3. 因为是内存数据库，其大小受到内存的限制
    - **为什么查询快**
      1. 存储在内存
      2. 优化的数据结构，redis可以看成是一个全局的hash表，并且全程使用hash结构或者一些特殊结构插入、查找都是O(1)的开销
      3. 使用I/O多路复用，非阻塞IO
      4. 采用单线程，保证原子操作，避免线程切换的上下文开销和竞争

12. ## Redis的数据类型有那些?

    key是string类型，value可以是string、hash、list、set、zset

    - string

      使用简单动态字符串SDS

      ```c
      /*  
       * 保存字符串对象的结构  
       */  
      struct sdshdr {  
          int len;  // buf 中已占用空间的长度  
          int free;  // buf 中剩余可用空间的长度
          char buf[];  // 数据空间  
      };
      ```

      1. 修改时会检查SDS的空间够不够，防止溢出，
      2. 获得长度时可以直接返回，C字符串要遍历到一直找到'\0'

    - list

      使用双向链表实现

    - hash

      hash其实是个字典，底层使用dictht结构体

      ```c
      typedef struct dictht {
         dictEntry **table;//哈希表数组   
         unsigned long size;//哈希表大小  
         unsigned long sizemask;//哈希表大小掩码，用于计算索引值
         unsigned long used;//该哈希表已有节点的数量
      }
      ```

      哈希表节点的结构体

      ```c
      typeof struct dictEntry{  
         void *key;//键
         union{  //不同键对应的值的类型可能不同，使用union来处理这个问题
            void *val;
            uint64_tu64;
            int64_ts64;
         }
         struct dictEntry *next;
      }
      ```

      ![hash](D:\xdu\面试\fig\redis-hash.png)

      可以看到在dict中有两个表，ht[1]指向的表平时是空的，当需要rehash时再为他开辟空间。

      若需要扩展哈希表，将为它开辟h[0]两倍大的空间

      渐进式rehash：不是一次性的将h[1]中的元素挪过来，是要求修改时或者空闲时一点点同步。rehash期间不影响外部对ht[0]的访问

    - set

      使用或者字典实现

      - 当set中元素全都是整型且少于512个时使用intset，其查找需要遍历

        ![set-intset](D:\xdu\面试\fig\redis-set-1.png)

      - 不满足时，使用字典，value设为空

        ![set-dict](D:\xdu\面试\fig\redis-set-2.png)

    - zset

      数据量少用ziplist（占用连续内存，查找需要顺序遍历），大用字典+zskiplist，字典用来根据数据查score，跳表用来根据score查数据

      ![zskiplist](D:\xdu\面试\fig\zskiplist.png)

13. ## Redis是单线程的还是多线程的，为什么?

    在redis5及之前是单线程的，在redis6引入了多线程

    但redis在核心的内存读写计算操作依然是单线程的，只有一个work队列，引入的多线程是用来和客户端连接，处理IO读写，**使用多线程提升读写解析数据的效率**，而在 **操作内存数据的时候还是用单线程**

14. ## Redis持久化机制有哪些

    **持久化是什么**

    将内存数据写到磁盘，防止系统崩溃导致数据丢失。

    **有两种持久化机制RDB和AOF**

    - RDB快照

      定时将数据库以快照的形式保存到磁盘，对应文件为dump.rdb，每次会取代上次生成的dump.rdb文件，只有一个rdb文件方便恢复，这个过程fork一个子进程执行，主进程不进行任何 IO 操作

    - AOF

      保存所有对数据库的指令到日志文件，并将其传输到磁盘，文件个数多。AOF有rewrite模式（文件个数过多时，会合并指令），在没有，rewrite时可以删除日志文件中的指令。

    **比较**

    AOF的更新频率更高、安全性更强，RDB持久化时系统宕机会造成数据丢失。但AOF通过append模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具恢复数据

    AOF文件更多更大，恢复速度慢

    两种都开启时，会有先用AOF

15. ## 缓存雪崩、击穿、穿透和解决办法

    - 缓存雪崩
      - 描述：大量的key同一时间过期，导致大量请求直接到达服务器。服务器压力骤增可能会数据库崩溃或服务不可用
      - 解决：设置热点key永不过期；随机设置key的过期时间，避免大量key同时过期
    - 击穿
      - 描述：在热点key过期的一瞬间，大量对key的查询请求直接到达服务器，导致服务器压力骤增
      - 解决：设置热点key永不过期；提前更新热点key的缓存时间；加互斥锁，缓存过期时只有一个线程能更新缓存，其他等待或返回旧数据
    - 穿透
      - 描述：查询大量无意义并不存在的key，大量请求直接到达服务器，从而失去缓存的意义。
      - 解决：布隆过滤器；参数校验，过滤掉不合法的请求。

16. ## 如何保证数据库和缓存的一致性

    1. 对于读写缓存，同写回策略，写缓存时，也同步写数据库，缓存和数据库中的数据一致，使用事务机制保证原子性

    2. 对于读缓存

       新增数据直接写入数据库，不会导致不一致

       删/改数据写入数据库并标记缓存中记录为无效

       此时有两种做法，先更新数据库再删缓存，先删缓存再更新数据库

       - 删除缓冲值和更新数据库失败而导致数据不一致，可以使用重试机制确保删除或者更新操作成功
         - 可以把要删除的缓存值或者要更新的数据库值暂存到消息队列中。当应用没有能够成功的删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或者更新
         - 如果能够成功删除或者更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存一致了。否则的话，我们还需要再次进行重试。如果重试超过一定次数，还是没有成功，我们就需要向应用层发送报错信息了
       - 先删缓存再更新数据库的方法，在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删
       - 当使用先更新数据库再删除缓存时，也有个地方需要注意，如果业务层要求必须读取一致的数据，那么，我们就需要在更新数据库时，先**在 Redis 缓存客户端暂存并发读请求**，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。

# C++

1. ## 静态变量和全局变量、局部变量的区别、在内存上是怎么分布的

   - 从内存分配看

     静态变量和全局变量放在静态存储区，静态变量和全局变量有初始值放在data区，没有就放在bss区初始值默认为0，局部变量放在栈区

   - 从作用域来看

     静态变量在声明它的范围内有效，离开这个范围这个变量仍然存在

     全局变量对于整个工程文件可见

     局部变量在声明它的{}内可见，离开这个范围会被销毁

2. ## 指针和引用的区别

   1. 指针和引用都是内存地址的概念，但指针是实体，引用是别名

   2. 指针和引用在编译期间都会被添加到符号表，但在符号表中指针的存储位置是指针变量的存储位置，引用的存储位置是指引用对象的存储位置，引用并不占用内存空间

   3. 引用设置之后不能更改、引用不能为空值，但指针可以

   4. sizeof 引用：返回的是代表对象的大小

      sizeof 指针：返回的是指针本身的大小

   5. 指针有const的概念，引用没有。

   6. 引用在声明时必须定义

   7. 作为参数传值时，传指针本身也是传变量，传这个指针变量，传引用的实质是传地址。

   **对于引用中const的一点解释**

   不允许非const引用指向需要临时对象的对象或值，即，编译器产生临时变量的时候引用必须为const

   const引用表示，试图通过此引用去(间接)改变其引用的对象的值时，编译器会报错

3. ## C++内存分区

   - 栈区 自动
   - 堆区 手动
   - 全局变量区（静态变量区）分为初始化区域（data数据段）和未初始化区域（bss数据段）
   - 代码段

   - 常量存储区

4. ## static关键字和const关键字的作用

   - **static控制变量的存储方式和可见范围**
     - **修饰全局变量**：使全局变量只在本文件中可见
     - **修饰局部变量**：是存储位置变为静态存储区，在离开局部变量的作用于之后，该变量仍然存在在内存中
     - **修饰模块中的函数**：只有在这里模块中的函数能够调用这个函数
     - **修饰模块中的变量**：只有在这个模块中的变量能够访问这个变量
     - **修饰类的成员函数/变量**：使成员函数/变量属于这个类，而不是属于这个类的对象。要在类内声明，类外初始化。static函数没有this指针作为参数
     - **修饰在函数体的变量**：下次再调用时，其值是上次的值。
   - **const保证变量不可被改变**
     - **修饰基本数据类型**
     - **修饰指针变量**：可以是指针常量或者常量指针
     - **修饰类对象**：const修饰的类对象只能调用const函数
     - **修饰成员函数**：在这个函数中不能改变类的成员变量，const和static关键字不能同时修饰一个成员函数
     - **修饰成员变量**：对于每个对象来说，这个成员变量是不可改变的，对于类来说，每个对象的成员值可以不同，因此，不能在类中初始化，要在构造函数的初始化列表中初始化。

5. ## 常量指针和指针常量之间有什么区别

   指针是一个变量，有自己的内存空间，其中写着指向对象的地址。

   - **指针常量**：const放在*的右边，指针常量是指，它内存空间中写的地址不能被改变。如：int * const
   - **常量指针**：const放在*的左边，表示指向对象的值不能改变，但指针可以指向其他常量。如：const int *

6. ## 结构体和类的区别

   结构体和类最大的区别是，类默认访问和继承的权限是private，而struct默认是public。在语义上，类的目的是实现具有复杂行为和功能的对象，结构体是通常用于数据的简单聚合，作为数据容器使用。

   类还可以用于定义模板参数，但struct不行。

7. ## 什么是智能指针，C++有哪几种智能指针

   智能指针是一种类模板，对指针进行封装，管理动态分配对象的生命周期，从而避免内存泄漏和悬空指针。

   - std::auto_ptr，在c11中已经被淘汰。
   - std::shared_ptr 共享所有权，允许复制和赋值，用引用计数管理生命周期，可能出现循环引用的问题
   - std::weaker_ptr 用来解决shared_ptr循环引用的问题，用weaker_ptr不会使引用计数增加，不能直接访问对象，通过lock()获得指向对象的shared_ptr
   - std::unique_ptr 独占式 不能复制，可以移动所有权

8. ## 智能指针的实现原理是什么

   智能指针基于RALL原则实现自动内存管理。依赖于模板类和运算符重载实现在智能指针生命周期内管理对所指对象的创建和摧毁。

   - std::unique_ptr
     - 构造函数初始化指针
     - 析构函数销毁对象
     - 禁止复制确保所有权独占
     - 实现移动语义完成所有权转移
   - std::shared_ptr
     - 引用计数（用一个控制块存储）
     - 构造函数时+1，析构函数-1，若为0则销毁对象
     - 复制+1
     - 控制块，包含引用计数和实际对象指针
   - std::weaker_ptr
     - 弱引用计数（控制块中一个额外的计数）
     - 实现lock()
     - 析构函数和构造函数会改变弱引用计数

9. ## new和malloc有什么区别

   new是c++关键字，malloc是库函数

   new会自动计算需要的内存空间大小，malloc需要用户自己计算

   new会在分配空间之后自动调用构造函数，malloc不会调用构造函数，不会自己初始化

   new失败会抛出异常std::bad_alloc，malloc会返回null

   new成功后会返回对象，malloc返回的是void*，需要自己进行类型转换

   new用delete释放，malloc用free释放

   new允许重载，malloc不允许

10. ## delete 和 free 有什么区别?

    delete是c++关键字，free是库函数

    delete会自动调用对象的析构函数，free不会调用析构函数

    delete会在对象超出作用域时自动调用

    delete允许重载，free不允许

    调用 free() 之前需要检查需要释放的指针是否为空。

11. ## 堆和栈的区别

    1. 管理方式不同

       堆需要程序员手动分配和回收，如用malloc和free。栈是由操作系统自动分配回收

    2. 生长方向不同

       栈向下生长，堆向上生长

    3. 空间大小不同

       栈的空间远小于堆，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

    4. 分配方式不同

       栈的分配有两种，动态和静态，静态分配是由操作系统完成的，动态由`alloca()`函数分配，释放依然由操作系统进行，不需要我们手动。堆的分配都是动态的，不需要连续

    5. 存放内容不同

       栈一般存放函数返回地址、相关参数、局部变量

       堆一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的

    6. 分配效率不同

       栈的分配有硬件层的支持，效率高，堆的分配由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，容易产生内存碎片，分配效率低

12. ## 什么是内存泄漏,如何检测和防止?

    **什么是**

    程序运行过程中，动态分配的内存没有被释放，导致内存资源浪费和程序性能下降。

    **如何检测和防止**

    检查代码，分配的内存是否都释放了；使用内存分析工具，如，Valgrind、Purify；使用智能指针，遵循RALL原则会自动管理内存；避免使用全局变量和静态变量

13. ## 什么是野指针?如何避免?

    **野指针**：指针指向的地址不可知；指向已释放或非分配内存地址的指针

    **成因**：指针没有进行初始化；释放后未置空；栈内存超出作用域

    **避免**：指针初始化；释放后置空；避免指针越界；指针使用之前检查有效性

14. ## C++面向对象三大特性

    - 封装

      隐藏对象的属性和实现细节仅对外公开接口和对象进行交互、降低耦合

    - 继承

      支持代码重用和拓展，允许程序员在保持原有类特性的基础上进行扩展，增加功能

    - 多态

      不同的对象通过同一个接口可以做出不同行为

15. ## 简述一下 C++的重载和重写，以及它们的区别和实现方式

    **重载**

    函数重载：两个函数的作用域一致、名字相同、参数不同，调用时根据参数列表确定调用哪个函数

    运算符重载：为用户定义的类型（如类或结构体）自定义运算符行为的一种功能，**运算符重载必须是类的成员函数或友元函数**。

    **重写**

    子类重写父类的虚函数，要求名字和参数要一致，在父类中要有virtual关键字修饰

    派生类调用时会调用派生类的重写函数，不会调用被重写函数

16. ## C++怎么实现多态

    **静态多态**：重载，在编译时期已经决定使用哪个函数，这由函数的参数列表确定

    **动态多态**：派生类继承基类时，对虚函数进行重写，在运行时根据虚函数表找到要调用的虚函数，在运行时确实是调用哪个函数

17. ## 虚函数和纯虚函数的区别

    虚函数是用virtual修饰的成员函数，纯虚函数是在函数声明的末尾写 = 0；

    对于纯虚函数，派生类必须重写，在基类中只有声明，没有定义

    有纯虚函数的类称为抽象类，定义了一种接口规范

    虚函数派生类可以不重写，到时候调用派生类的这个函数时，会调用其基类的这个函数

18. ## 虚函数怎么实现的

    **依赖虚函数指针和虚函数表实现**

    当一个类有虚函数时，编译器会为这个类生成一个隐藏成员——虚函数指针，这个指针指向一个数组，这个数组被称为虚函数表，用来存放虚函数的地址。

    基类有基类的虚函数表和虚函数指针，派生类继承基类后，因为有虚函数，派生类也会有自己的虚函数表，若派生类对虚函数重写，则将虚函数表中这个函数的地址写为派生类的这个函数的地址，如果派生类没有进行重写，这个位置将写的是基类的该虚函数的地址。

    调用虚函数时，会通过虚函数指针到达虚函数表，从中找出虚函数的地址。

19. ## 虚函数表是什么

    实现多态的关键机制，是一个保存该类的虚函数地址的数组

20. ## 什么是构造函数和析构函数?构造函数、析构函数可以是虚函数嘛?

    **构造函数**：用来在创建对象时进行初始化。

    **析构函数**：用来在对象结束其生命周期时，完成释放申请的内存空间等“善后”工作。

    析构函数可以且最好写为虚函数，构造函数不可以

    如果基类的析构函数没有声明是虚函数，在当删除**基类指针**指向的**派生类**对象时，会因为它被编译器认为是基类对象，而调用到基类的析构函数，导致在派生类中申请的内存没有被释放。

    构造函数不可以是虚函数，因为虚函数的调用要用到虚函数表，而调用构造函数时虚函数表还没有生成。这违背了先实例化在调用的准则。

21. ## C++构造函数有几种，分别什么作用

    无参构造函数 默认的初始化函数 有带参数的构造函数时，不会默认生成无参构造函数，需要显式的写出来

    一般构造函数 可以进行重载，根据实际灵活的进行初始化

    拷贝构造 会默认生成，但对于指针成员变量，默认会是浅拷贝，可以用深拷贝自己写一个

    移动构造函数 利用移动语义，提高效率，避免不必要的深拷贝

    赋值运算符重载，类似于拷贝构造

    类型转换构造函数 不允许默认转换，将构造函数用explict修饰

22. ## 深拷贝与浅拷贝的区别

    浅拷贝会出现两个指针指向一个对象（指向同一个地址），深拷贝会重新生成一个这个对象，两个指针指向两个对象，只是这两个对象的数据相同，但地址不同

23. ## STL 容器了解哪些

    array

    vector

    list

    deque

    queue

    stack

    heap

    priority_queue

    set

    muitiset

    map

    multimap

    unordered_map

    unordered_set

    unordered_multimap

    unordered_multiset

24. ## vector和list的区别

    vector的地址连续， list地址不连续

    vector可以实现O(1)随机访问，list不行

    对于插入、删除，list的开销很小，而vector只有在结尾插入删除开销才小

    vector在插入之后会造成迭代器失效，list不会

    删除vector和list的当前迭代器都会失效，需要更新

    vector的内存碎片会比list少

25. ## vector底层原理和扩容过程

    vector是一段连续的线性空间，用三个迭代器来表示，一个指向vector容器的开始，一个指向当前容器最后一个元素末尾字节，一个指向当前容器的末尾字节

    当vector的大小和容量相等时，扩容

    扩容是重新开辟一段空间，空间大小为原来的k倍（k一般为1.5或者2），再把按顺序移动到新的空间

    **为什么k倍扩容**：与等长扩容相比，k倍扩容的开销更小，拷贝次数。一个是O(n)，一个是O(1)

    **为什么是1.5或者2**：1.5或者2可以做到，在几次扩容之后，就可以再次扩容时使用之前的空间了。提高了空间利用率

26. ## push_back()和emplace_back()的区别

    emplace_back() 为原地构造，开销更小

    push_back()首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中

    emplace_back() 省去了拷贝或者移动元素的过程

27. ## map deque list的实现原理

    - **map**

      底层为红黑树，map中的元素是键-值对，以key作为索引，key不可修改

    - **deque**

      底层是分段连续的空间（默认是每段512字节），要维护其看似连续的假象

      deque有一个map用来指向每一段连续的空间

      ![deque](D:\xdu\面试\fig\deque.png)

      它的迭代器要有指向当前值的指针和指向当前连续空间头尾的指针以及指向当前连续空间所对应在map的节点

      ![deque-iterator](D:\xdu\面试\fig\deque-iterator.png)

    - **list**

       底层是双向链表，每个节点包含指向上一个节点的指针和指向下一个节点的指针

      迭代器包含指向链表头和尾的指针

      ![list-iterator](D:\xdu\面试\fig\list.png)

28. ## map && unordered_map的区别和实现机制

    - map底层是红黑树，插入查询是O(log n)，是有序结构
    - unordered_map底层是哈希表，插入查询是O(1)，无序结构

29. ## C++11新特性有哪些

    - 空指针

    - assertion

      新增一个编译期的assert：`static_assert`

    - lambda表达式
    - auto和decltype
    - 范围循环
    - 模板类
    - 智能指针
    - 初始化列表
    - 多线程支持
    - override和final
    - 正则化表达式
    - 右值引用

30. ## 移动语义有什么作用，原理是什么

    移动语义其实是在转移对象的所有权，为不需要深拷贝的情况降低开销，避免不必要的资源复制和释放，从而提高性能。

    将资源的所有权从临时对象或者右值对象转移到目标对象，并将临时对象或者右值对象置空

31. ## 左值引用和右值引用的区别

    左值引用使用&，引用一个具名的对象，对引用进行修改会反映在对应的原始对象上

    右值引用使用&&，引用右值，实现移动语义、完美转发

32. ## 说一下lambda函数

    lambda函数返回的是一个函数对象或者仿函数

    语法[capture] (prarams) mutable -> return-type {statement}

    其中[capture]捕捉列表， (prarams)参数，mutable关键字，type返回类型，statement函数体

    lambda函数可以用作函数的参数，通过这种方式实现回调函数

33. ## C++如何实现一个单例模式

    **单例模式**是在整个应用程序只创建一个实例，并提供一个它的全局访问点。目的是节约资源和方便控制。

    有两种实现模式，

    - 懒汉（加锁）

      构造函数为private

      禁用拷贝构造函数和赋值操作符

      唯一的实例对象静态变量一开始定义为空`Singleton* Singleton::g_pSingleton = nullptr`

      设置一个public的static函数，返回`*g_pSingleton`

      在这个函数内部，判断这个唯一的实例对象为不为空，为空则获得锁，得到锁之后再判断为不为空，为空就实例化它，释放锁，返回这个对象。

    - 饿汉

      构造函数为private

      禁用拷贝构造函数和赋值操作符

      唯一单实例对象指针    `static Singleton *g_pSingleton;`也是private

      设置一个public的static函数，返回`*g_pSingleton`

      代码一运行就会初始化创建实例 `Singleton* Singleton::g_pSingleton = new (std::nothrow) Singleton();` 由主线程自己创建，可以保证线程安全。

34. ## 什么是菱形继承

    多继承时可能会出现的一种特殊情况，有基类A，B和C都是继承了A，D继承B和C，会出现这种情况。

    ```css
        A
       / \
      B   C
       \ /
        D
    ```

    这种是菱形继承，可能会带来*二义性*和*冗余*的问题。

    二义性是指无法直接通过变量名进行读取，需要通过域(::)成员运算符进行区分

    可以使用虚继承解决，虚继承的形式为子类: virtual public 父类，使得在派生类中只保留一份基类成员

35. ## C++中的多线程同步机制

    - 互斥锁 std::lock_guard，std::unique_lock，std::mutex
    - 条件变量  std::condition_variable
    - 原子操作 std::atomic 和 std::atomic_flag
    - 信号量
    - Latch
    - Barrier

36. ## 如何在C++中创建和管理线程?

    在c++中和线程相关的操作会用到`<thread>`头文件

    **创建线程**`std::thread t(function)`，function表示要线程执行的函数

    使用`join（）`等待线程执行完成，使用`detch()`使线程完成后自动释放资源

    **管理线程**需要用到std::mutex互斥量，std::condition_variable条件变量和std::promise及std::future完成。

37. ## Socket套接字网络编程流程

    | 客户端                     | 服务器                    |
    | -------------------------- | ------------------------- |
    |                            | 创建socket套接字 socket() |
    |                            | 绑定IP地址和端口 bind()   |
    | 创建socket套接字 socket()  | 设置为监听模式 listen()   |
    | 向服务器发起连接 connect() | 接受客户端连接 accept()   |
    | 发送/接收数据 send/recv()  | 发送/接收数据 send/recv() |
    | 关闭连接 close()           | 关闭连接 close()          |

    

38. ## vs编译的过程

    - 预处理

      宏展开

      文件包含

      条件编译

    - 编译

      语法检查

      语义分析

      优化

      这个阶段的错误主要是语法错误

      输出汇编文件，一般是.s的拓展名

    - 汇编

      将汇编代码转化为机器代码

      生成.obj文件

      这个时候的错误主要是重复定义变量

    - 链接

      符号解析、地址重定位、合并代码段数据段、生成可执行文件

39. ## 静态编译和动态编译

    **静态编译**：在编译时，将动态链接库的对应部分提取出来，连接到可执行文件中，可执行文件在运行时不需要依赖动态链接库

    **动态编译**：可执行文件需要附带一个动态链接库，编译速度提高

40. ## 动态链接和静态链接

    静态链接：将.lib文件直接放入目标程序

    动态链接：把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息连接到目标程序，程序运行时根据信息去找对应的函数代码。

41. ## 静态联编和动态联编 

    **联编**是指计算机程序的不同部分彼此关联的过程

    **静态联编**是指联编工作在编译阶段完成，又叫早期联编

    **动态联编**实际上是在运行虚函数时实现。

